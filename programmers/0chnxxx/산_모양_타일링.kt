/**
 * 한 변의 길이가 1인 정삼각형 2n + 1개를 이어붙여 윗변의 길이가 n, 아랫변의 길이가 n + 1인 사다리꼴을 만들 수 있습니다.
 * 이때 사다리꼴의 윗변과 변을 공유하는 n개의 정삼각형 중 일부의 위쪽에 같은 크기의 정삼각형을 붙여 새로운 모양을 만들었습니다.
 * 이렇게 만든 모양을 정삼각형 타일 또는 정삼각형 2개를 이어 붙인 마름모 타일로 빈 곳이 없도록 채우려고 합니다.
 * 정삼각형 타일과 마름모 타일은 돌려서 사용할 수 있습니다.
 *
 * 사다리꼴의 윗변을 나타내는 정수 n과 사다리꼴 윗변에 붙인 정삼각형을 나타내는 1차원 정수 배열 tops가 매개변수로 주어집니다.
 * 이때 문제 설명에 따라 만든 모양을 정삼각형 또는 마름모 타일로 빈 곳이 없도록 채우는 경우의 수를 10007로 나눈 나머지를 return 하도록 solution 함수를 완성해 주세요.
 *
 * 1 <= n <= 100000
 * tops의 길이 = n
 * tops[i]는 사다리꼴의 윗변과 변을 공유하는 i + 1번째 정삼각형의 위쪽에 정삼각형을 붙이는 경우 1, 붙이지 않는 경우 0입니다.
 */

fun main() {
    val n = 4
    val tops = intArrayOf(1, 1, 0, 1)

    val solution = Solution().solution(n, tops)

    println(solution)
}

class Solution {
    fun solution(n: Int, tops: IntArray): Int {
        val mod = 10007

        // 1-based index
        // IntArray는 n의 가장 우측 삼각형을 사용하는지 여부
        val dp = Array(n) { IntArray(2) }

        // 초기값
        if (tops[0] == 1) { // 탑이 있는 경우
            dp[0][0] = 3 // 우측 삼각형을 사용하지 않으면 3가지
            dp[0][1] = 4 // 우측 삼각형을 사용하면 4가지
        } else { // 탑이 없는 경우
            dp[0][0] = 2 // 우측 삼각형을 사용하지 않으면 2가지
            dp[0][1] = 3 // 우측 삼각형을 사용하면 3가지
        }

        for (i in 1 until n) {
            if (tops[i] == 1) {
                dp[i][0] = (dp[i - 1][1] * 2 + dp[i - 1][0]) % mod
                dp[i][1] = (dp[i - 1][1] * 3 + dp[i - 1][0]) % mod
            } else {
                dp[i][0] = (dp[i - 1][1] + dp[i - 1][0]) % mod
                dp[i][1] = (dp[i - 1][1] * 2 + dp[i - 1][0]) % mod
            }
        }

        return dp[n - 1][1]
    }
}

